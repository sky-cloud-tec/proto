// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.2
// source: src/grpc/nap.proto

package rpc

import (
	context "context"
	common "github.com/sky-cloud-tec/proto/v1/common"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// NapDeviceServiceClient is the client API for NapDeviceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapDeviceServiceClient interface {
	PullDeviceConfig(ctx context.Context, in *ByDeviceAndTaskRequest, opts ...grpc.CallOption) (*PullDeviceConfigResponse, error)
	CheckDeviceState(ctx context.Context, in *ByIdRequest, opts ...grpc.CallOption) (*common.SimpleJsonResponse, error)
	GetTemplateDevice(ctx context.Context, in *ByDeviceIdAndDeviceTypeAndKeyRequest, opts ...grpc.CallOption) (*GetTemplateDeviceResponse, error)
	PullRouteConfig(ctx context.Context, in *ByDeviceAndTaskRequest, opts ...grpc.CallOption) (*PullDeviceConfigResponse, error)
	PullHitCountConfig(ctx context.Context, in *ByDeviceAndTaskRequest, opts ...grpc.CallOption) (*PullDeviceConfigResponse, error)
	PullUserIDConfig(ctx context.Context, in *ByDeviceAndTaskRequest, opts ...grpc.CallOption) (*PullDeviceConfigResponse, error)
	SendDeviceState(ctx context.Context, in *SendDeviceStateRequest, opts ...grpc.CallOption) (*SendDeviceStateResponse, error)
}

type napDeviceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapDeviceServiceClient(cc grpc.ClientConnInterface) NapDeviceServiceClient {
	return &napDeviceServiceClient{cc}
}

func (c *napDeviceServiceClient) PullDeviceConfig(ctx context.Context, in *ByDeviceAndTaskRequest, opts ...grpc.CallOption) (*PullDeviceConfigResponse, error) {
	out := new(PullDeviceConfigResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapDeviceService/PullDeviceConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *napDeviceServiceClient) CheckDeviceState(ctx context.Context, in *ByIdRequest, opts ...grpc.CallOption) (*common.SimpleJsonResponse, error) {
	out := new(common.SimpleJsonResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapDeviceService/CheckDeviceState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *napDeviceServiceClient) GetTemplateDevice(ctx context.Context, in *ByDeviceIdAndDeviceTypeAndKeyRequest, opts ...grpc.CallOption) (*GetTemplateDeviceResponse, error) {
	out := new(GetTemplateDeviceResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapDeviceService/GetTemplateDevice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *napDeviceServiceClient) PullRouteConfig(ctx context.Context, in *ByDeviceAndTaskRequest, opts ...grpc.CallOption) (*PullDeviceConfigResponse, error) {
	out := new(PullDeviceConfigResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapDeviceService/PullRouteConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *napDeviceServiceClient) PullHitCountConfig(ctx context.Context, in *ByDeviceAndTaskRequest, opts ...grpc.CallOption) (*PullDeviceConfigResponse, error) {
	out := new(PullDeviceConfigResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapDeviceService/PullHitCountConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *napDeviceServiceClient) PullUserIDConfig(ctx context.Context, in *ByDeviceAndTaskRequest, opts ...grpc.CallOption) (*PullDeviceConfigResponse, error) {
	out := new(PullDeviceConfigResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapDeviceService/PullUserIDConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *napDeviceServiceClient) SendDeviceState(ctx context.Context, in *SendDeviceStateRequest, opts ...grpc.CallOption) (*SendDeviceStateResponse, error) {
	out := new(SendDeviceStateResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapDeviceService/SendDeviceState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapDeviceServiceServer is the server API for NapDeviceService service.
// All implementations must embed UnimplementedNapDeviceServiceServer
// for forward compatibility
type NapDeviceServiceServer interface {
	PullDeviceConfig(context.Context, *ByDeviceAndTaskRequest) (*PullDeviceConfigResponse, error)
	CheckDeviceState(context.Context, *ByIdRequest) (*common.SimpleJsonResponse, error)
	GetTemplateDevice(context.Context, *ByDeviceIdAndDeviceTypeAndKeyRequest) (*GetTemplateDeviceResponse, error)
	PullRouteConfig(context.Context, *ByDeviceAndTaskRequest) (*PullDeviceConfigResponse, error)
	PullHitCountConfig(context.Context, *ByDeviceAndTaskRequest) (*PullDeviceConfigResponse, error)
	PullUserIDConfig(context.Context, *ByDeviceAndTaskRequest) (*PullDeviceConfigResponse, error)
	SendDeviceState(context.Context, *SendDeviceStateRequest) (*SendDeviceStateResponse, error)
	mustEmbedUnimplementedNapDeviceServiceServer()
}

// UnimplementedNapDeviceServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapDeviceServiceServer struct {
}

func (UnimplementedNapDeviceServiceServer) PullDeviceConfig(context.Context, *ByDeviceAndTaskRequest) (*PullDeviceConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PullDeviceConfig not implemented")
}
func (UnimplementedNapDeviceServiceServer) CheckDeviceState(context.Context, *ByIdRequest) (*common.SimpleJsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckDeviceState not implemented")
}
func (UnimplementedNapDeviceServiceServer) GetTemplateDevice(context.Context, *ByDeviceIdAndDeviceTypeAndKeyRequest) (*GetTemplateDeviceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTemplateDevice not implemented")
}
func (UnimplementedNapDeviceServiceServer) PullRouteConfig(context.Context, *ByDeviceAndTaskRequest) (*PullDeviceConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PullRouteConfig not implemented")
}
func (UnimplementedNapDeviceServiceServer) PullHitCountConfig(context.Context, *ByDeviceAndTaskRequest) (*PullDeviceConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PullHitCountConfig not implemented")
}
func (UnimplementedNapDeviceServiceServer) PullUserIDConfig(context.Context, *ByDeviceAndTaskRequest) (*PullDeviceConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PullUserIDConfig not implemented")
}
func (UnimplementedNapDeviceServiceServer) SendDeviceState(context.Context, *SendDeviceStateRequest) (*SendDeviceStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendDeviceState not implemented")
}
func (UnimplementedNapDeviceServiceServer) mustEmbedUnimplementedNapDeviceServiceServer() {}

// UnsafeNapDeviceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapDeviceServiceServer will
// result in compilation errors.
type UnsafeNapDeviceServiceServer interface {
	mustEmbedUnimplementedNapDeviceServiceServer()
}

func RegisterNapDeviceServiceServer(s grpc.ServiceRegistrar, srv NapDeviceServiceServer) {
	s.RegisterService(&NapDeviceService_ServiceDesc, srv)
}

func _NapDeviceService_PullDeviceConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByDeviceAndTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapDeviceServiceServer).PullDeviceConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapDeviceService/PullDeviceConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapDeviceServiceServer).PullDeviceConfig(ctx, req.(*ByDeviceAndTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NapDeviceService_CheckDeviceState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapDeviceServiceServer).CheckDeviceState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapDeviceService/CheckDeviceState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapDeviceServiceServer).CheckDeviceState(ctx, req.(*ByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NapDeviceService_GetTemplateDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByDeviceIdAndDeviceTypeAndKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapDeviceServiceServer).GetTemplateDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapDeviceService/GetTemplateDevice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapDeviceServiceServer).GetTemplateDevice(ctx, req.(*ByDeviceIdAndDeviceTypeAndKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NapDeviceService_PullRouteConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByDeviceAndTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapDeviceServiceServer).PullRouteConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapDeviceService/PullRouteConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapDeviceServiceServer).PullRouteConfig(ctx, req.(*ByDeviceAndTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NapDeviceService_PullHitCountConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByDeviceAndTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapDeviceServiceServer).PullHitCountConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapDeviceService/PullHitCountConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapDeviceServiceServer).PullHitCountConfig(ctx, req.(*ByDeviceAndTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NapDeviceService_PullUserIDConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByDeviceAndTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapDeviceServiceServer).PullUserIDConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapDeviceService/PullUserIDConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapDeviceServiceServer).PullUserIDConfig(ctx, req.(*ByDeviceAndTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NapDeviceService_SendDeviceState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendDeviceStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapDeviceServiceServer).SendDeviceState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapDeviceService/SendDeviceState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapDeviceServiceServer).SendDeviceState(ctx, req.(*SendDeviceStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapDeviceService_ServiceDesc is the grpc.ServiceDesc for NapDeviceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapDeviceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapDeviceService",
	HandlerType: (*NapDeviceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PullDeviceConfig",
			Handler:    _NapDeviceService_PullDeviceConfig_Handler,
		},
		{
			MethodName: "CheckDeviceState",
			Handler:    _NapDeviceService_CheckDeviceState_Handler,
		},
		{
			MethodName: "GetTemplateDevice",
			Handler:    _NapDeviceService_GetTemplateDevice_Handler,
		},
		{
			MethodName: "PullRouteConfig",
			Handler:    _NapDeviceService_PullRouteConfig_Handler,
		},
		{
			MethodName: "PullHitCountConfig",
			Handler:    _NapDeviceService_PullHitCountConfig_Handler,
		},
		{
			MethodName: "PullUserIDConfig",
			Handler:    _NapDeviceService_PullUserIDConfig_Handler,
		},
		{
			MethodName: "SendDeviceState",
			Handler:    _NapDeviceService_SendDeviceState_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapRawConfigServiceClient is the client API for NapRawConfigService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapRawConfigServiceClient interface {
	ImportRawConfig(ctx context.Context, in *WithRawConfigRequest, opts ...grpc.CallOption) (*common.SimpleJsonResponse, error)
	DeleteRawConfig(ctx context.Context, in *ByIdRequest, opts ...grpc.CallOption) (*common.SimpleJsonResponse, error)
	ListRawConfig(ctx context.Context, in *ByDeviceAndPageRequest, opts ...grpc.CallOption) (*ListRawConfigResponse, error)
	GetRawConfig(ctx context.Context, in *ByIdRequest, opts ...grpc.CallOption) (*GetRawConfigResponse, error)
	CleanRawConfig(ctx context.Context, in *CleanRawConfigRequest, opts ...grpc.CallOption) (*CleanRawConfigResponse, error)
}

type napRawConfigServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapRawConfigServiceClient(cc grpc.ClientConnInterface) NapRawConfigServiceClient {
	return &napRawConfigServiceClient{cc}
}

func (c *napRawConfigServiceClient) ImportRawConfig(ctx context.Context, in *WithRawConfigRequest, opts ...grpc.CallOption) (*common.SimpleJsonResponse, error) {
	out := new(common.SimpleJsonResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapRawConfigService/ImportRawConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *napRawConfigServiceClient) DeleteRawConfig(ctx context.Context, in *ByIdRequest, opts ...grpc.CallOption) (*common.SimpleJsonResponse, error) {
	out := new(common.SimpleJsonResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapRawConfigService/DeleteRawConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *napRawConfigServiceClient) ListRawConfig(ctx context.Context, in *ByDeviceAndPageRequest, opts ...grpc.CallOption) (*ListRawConfigResponse, error) {
	out := new(ListRawConfigResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapRawConfigService/ListRawConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *napRawConfigServiceClient) GetRawConfig(ctx context.Context, in *ByIdRequest, opts ...grpc.CallOption) (*GetRawConfigResponse, error) {
	out := new(GetRawConfigResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapRawConfigService/GetRawConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *napRawConfigServiceClient) CleanRawConfig(ctx context.Context, in *CleanRawConfigRequest, opts ...grpc.CallOption) (*CleanRawConfigResponse, error) {
	out := new(CleanRawConfigResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapRawConfigService/CleanRawConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapRawConfigServiceServer is the server API for NapRawConfigService service.
// All implementations must embed UnimplementedNapRawConfigServiceServer
// for forward compatibility
type NapRawConfigServiceServer interface {
	ImportRawConfig(context.Context, *WithRawConfigRequest) (*common.SimpleJsonResponse, error)
	DeleteRawConfig(context.Context, *ByIdRequest) (*common.SimpleJsonResponse, error)
	ListRawConfig(context.Context, *ByDeviceAndPageRequest) (*ListRawConfigResponse, error)
	GetRawConfig(context.Context, *ByIdRequest) (*GetRawConfigResponse, error)
	CleanRawConfig(context.Context, *CleanRawConfigRequest) (*CleanRawConfigResponse, error)
	mustEmbedUnimplementedNapRawConfigServiceServer()
}

// UnimplementedNapRawConfigServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapRawConfigServiceServer struct {
}

func (UnimplementedNapRawConfigServiceServer) ImportRawConfig(context.Context, *WithRawConfigRequest) (*common.SimpleJsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportRawConfig not implemented")
}
func (UnimplementedNapRawConfigServiceServer) DeleteRawConfig(context.Context, *ByIdRequest) (*common.SimpleJsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRawConfig not implemented")
}
func (UnimplementedNapRawConfigServiceServer) ListRawConfig(context.Context, *ByDeviceAndPageRequest) (*ListRawConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRawConfig not implemented")
}
func (UnimplementedNapRawConfigServiceServer) GetRawConfig(context.Context, *ByIdRequest) (*GetRawConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRawConfig not implemented")
}
func (UnimplementedNapRawConfigServiceServer) CleanRawConfig(context.Context, *CleanRawConfigRequest) (*CleanRawConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CleanRawConfig not implemented")
}
func (UnimplementedNapRawConfigServiceServer) mustEmbedUnimplementedNapRawConfigServiceServer() {}

// UnsafeNapRawConfigServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapRawConfigServiceServer will
// result in compilation errors.
type UnsafeNapRawConfigServiceServer interface {
	mustEmbedUnimplementedNapRawConfigServiceServer()
}

func RegisterNapRawConfigServiceServer(s grpc.ServiceRegistrar, srv NapRawConfigServiceServer) {
	s.RegisterService(&NapRawConfigService_ServiceDesc, srv)
}

func _NapRawConfigService_ImportRawConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithRawConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapRawConfigServiceServer).ImportRawConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapRawConfigService/ImportRawConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapRawConfigServiceServer).ImportRawConfig(ctx, req.(*WithRawConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NapRawConfigService_DeleteRawConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapRawConfigServiceServer).DeleteRawConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapRawConfigService/DeleteRawConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapRawConfigServiceServer).DeleteRawConfig(ctx, req.(*ByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NapRawConfigService_ListRawConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByDeviceAndPageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapRawConfigServiceServer).ListRawConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapRawConfigService/ListRawConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapRawConfigServiceServer).ListRawConfig(ctx, req.(*ByDeviceAndPageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NapRawConfigService_GetRawConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapRawConfigServiceServer).GetRawConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapRawConfigService/GetRawConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapRawConfigServiceServer).GetRawConfig(ctx, req.(*ByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NapRawConfigService_CleanRawConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CleanRawConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapRawConfigServiceServer).CleanRawConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapRawConfigService/CleanRawConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapRawConfigServiceServer).CleanRawConfig(ctx, req.(*CleanRawConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapRawConfigService_ServiceDesc is the grpc.ServiceDesc for NapRawConfigService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapRawConfigService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapRawConfigService",
	HandlerType: (*NapRawConfigServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportRawConfig",
			Handler:    _NapRawConfigService_ImportRawConfig_Handler,
		},
		{
			MethodName: "DeleteRawConfig",
			Handler:    _NapRawConfigService_DeleteRawConfig_Handler,
		},
		{
			MethodName: "ListRawConfig",
			Handler:    _NapRawConfigService_ListRawConfig_Handler,
		},
		{
			MethodName: "GetRawConfig",
			Handler:    _NapRawConfigService_GetRawConfig_Handler,
		},
		{
			MethodName: "CleanRawConfig",
			Handler:    _NapRawConfigService_CleanRawConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapAddressServiceClient is the client API for NapAddressService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapAddressServiceClient interface {
	ImportAddresses(ctx context.Context, in *WithAddressAndDeviceRequest, opts ...grpc.CallOption) (*ImportAddressesResponse, error)
	RebuildAddressIndex(ctx context.Context, in *ByIdRequest, opts ...grpc.CallOption) (*common.SimpleJsonResponse, error)
}

type napAddressServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapAddressServiceClient(cc grpc.ClientConnInterface) NapAddressServiceClient {
	return &napAddressServiceClient{cc}
}

func (c *napAddressServiceClient) ImportAddresses(ctx context.Context, in *WithAddressAndDeviceRequest, opts ...grpc.CallOption) (*ImportAddressesResponse, error) {
	out := new(ImportAddressesResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapAddressService/ImportAddresses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *napAddressServiceClient) RebuildAddressIndex(ctx context.Context, in *ByIdRequest, opts ...grpc.CallOption) (*common.SimpleJsonResponse, error) {
	out := new(common.SimpleJsonResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapAddressService/rebuildAddressIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapAddressServiceServer is the server API for NapAddressService service.
// All implementations must embed UnimplementedNapAddressServiceServer
// for forward compatibility
type NapAddressServiceServer interface {
	ImportAddresses(context.Context, *WithAddressAndDeviceRequest) (*ImportAddressesResponse, error)
	RebuildAddressIndex(context.Context, *ByIdRequest) (*common.SimpleJsonResponse, error)
	mustEmbedUnimplementedNapAddressServiceServer()
}

// UnimplementedNapAddressServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapAddressServiceServer struct {
}

func (UnimplementedNapAddressServiceServer) ImportAddresses(context.Context, *WithAddressAndDeviceRequest) (*ImportAddressesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportAddresses not implemented")
}
func (UnimplementedNapAddressServiceServer) RebuildAddressIndex(context.Context, *ByIdRequest) (*common.SimpleJsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RebuildAddressIndex not implemented")
}
func (UnimplementedNapAddressServiceServer) mustEmbedUnimplementedNapAddressServiceServer() {}

// UnsafeNapAddressServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapAddressServiceServer will
// result in compilation errors.
type UnsafeNapAddressServiceServer interface {
	mustEmbedUnimplementedNapAddressServiceServer()
}

func RegisterNapAddressServiceServer(s grpc.ServiceRegistrar, srv NapAddressServiceServer) {
	s.RegisterService(&NapAddressService_ServiceDesc, srv)
}

func _NapAddressService_ImportAddresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithAddressAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapAddressServiceServer).ImportAddresses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapAddressService/ImportAddresses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapAddressServiceServer).ImportAddresses(ctx, req.(*WithAddressAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NapAddressService_RebuildAddressIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapAddressServiceServer).RebuildAddressIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapAddressService/rebuildAddressIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapAddressServiceServer).RebuildAddressIndex(ctx, req.(*ByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapAddressService_ServiceDesc is the grpc.ServiceDesc for NapAddressService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapAddressService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapAddressService",
	HandlerType: (*NapAddressServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportAddresses",
			Handler:    _NapAddressService_ImportAddresses_Handler,
		},
		{
			MethodName: "rebuildAddressIndex",
			Handler:    _NapAddressService_RebuildAddressIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapInterfaceServiceClient is the client API for NapInterfaceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapInterfaceServiceClient interface {
	ImportInterfaces(ctx context.Context, in *WithInterfacesAndDeviceRequest, opts ...grpc.CallOption) (*ImportInterfacesResponse, error)
}

type napInterfaceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapInterfaceServiceClient(cc grpc.ClientConnInterface) NapInterfaceServiceClient {
	return &napInterfaceServiceClient{cc}
}

func (c *napInterfaceServiceClient) ImportInterfaces(ctx context.Context, in *WithInterfacesAndDeviceRequest, opts ...grpc.CallOption) (*ImportInterfacesResponse, error) {
	out := new(ImportInterfacesResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapInterfaceService/ImportInterfaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapInterfaceServiceServer is the server API for NapInterfaceService service.
// All implementations must embed UnimplementedNapInterfaceServiceServer
// for forward compatibility
type NapInterfaceServiceServer interface {
	ImportInterfaces(context.Context, *WithInterfacesAndDeviceRequest) (*ImportInterfacesResponse, error)
	mustEmbedUnimplementedNapInterfaceServiceServer()
}

// UnimplementedNapInterfaceServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapInterfaceServiceServer struct {
}

func (UnimplementedNapInterfaceServiceServer) ImportInterfaces(context.Context, *WithInterfacesAndDeviceRequest) (*ImportInterfacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportInterfaces not implemented")
}
func (UnimplementedNapInterfaceServiceServer) mustEmbedUnimplementedNapInterfaceServiceServer() {}

// UnsafeNapInterfaceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapInterfaceServiceServer will
// result in compilation errors.
type UnsafeNapInterfaceServiceServer interface {
	mustEmbedUnimplementedNapInterfaceServiceServer()
}

func RegisterNapInterfaceServiceServer(s grpc.ServiceRegistrar, srv NapInterfaceServiceServer) {
	s.RegisterService(&NapInterfaceService_ServiceDesc, srv)
}

func _NapInterfaceService_ImportInterfaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithInterfacesAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapInterfaceServiceServer).ImportInterfaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapInterfaceService/ImportInterfaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapInterfaceServiceServer).ImportInterfaces(ctx, req.(*WithInterfacesAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapInterfaceService_ServiceDesc is the grpc.ServiceDesc for NapInterfaceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapInterfaceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapInterfaceService",
	HandlerType: (*NapInterfaceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportInterfaces",
			Handler:    _NapInterfaceService_ImportInterfaces_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapZoneServiceClient is the client API for NapZoneService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapZoneServiceClient interface {
	ImportZones(ctx context.Context, in *WithZonesAndDeviceRequest, opts ...grpc.CallOption) (*ImportZonesResponse, error)
}

type napZoneServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapZoneServiceClient(cc grpc.ClientConnInterface) NapZoneServiceClient {
	return &napZoneServiceClient{cc}
}

func (c *napZoneServiceClient) ImportZones(ctx context.Context, in *WithZonesAndDeviceRequest, opts ...grpc.CallOption) (*ImportZonesResponse, error) {
	out := new(ImportZonesResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapZoneService/ImportZones", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapZoneServiceServer is the server API for NapZoneService service.
// All implementations must embed UnimplementedNapZoneServiceServer
// for forward compatibility
type NapZoneServiceServer interface {
	ImportZones(context.Context, *WithZonesAndDeviceRequest) (*ImportZonesResponse, error)
	mustEmbedUnimplementedNapZoneServiceServer()
}

// UnimplementedNapZoneServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapZoneServiceServer struct {
}

func (UnimplementedNapZoneServiceServer) ImportZones(context.Context, *WithZonesAndDeviceRequest) (*ImportZonesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportZones not implemented")
}
func (UnimplementedNapZoneServiceServer) mustEmbedUnimplementedNapZoneServiceServer() {}

// UnsafeNapZoneServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapZoneServiceServer will
// result in compilation errors.
type UnsafeNapZoneServiceServer interface {
	mustEmbedUnimplementedNapZoneServiceServer()
}

func RegisterNapZoneServiceServer(s grpc.ServiceRegistrar, srv NapZoneServiceServer) {
	s.RegisterService(&NapZoneService_ServiceDesc, srv)
}

func _NapZoneService_ImportZones_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithZonesAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapZoneServiceServer).ImportZones(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapZoneService/ImportZones",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapZoneServiceServer).ImportZones(ctx, req.(*WithZonesAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapZoneService_ServiceDesc is the grpc.ServiceDesc for NapZoneService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapZoneService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapZoneService",
	HandlerType: (*NapZoneServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportZones",
			Handler:    _NapZoneService_ImportZones_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapNatObjectServiceClient is the client API for NapNatObjectService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapNatObjectServiceClient interface {
	ImportNatObjects(ctx context.Context, in *WithNatObjectsAndDeviceRequest, opts ...grpc.CallOption) (*ImportNatObjectsResponse, error)
}

type napNatObjectServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapNatObjectServiceClient(cc grpc.ClientConnInterface) NapNatObjectServiceClient {
	return &napNatObjectServiceClient{cc}
}

func (c *napNatObjectServiceClient) ImportNatObjects(ctx context.Context, in *WithNatObjectsAndDeviceRequest, opts ...grpc.CallOption) (*ImportNatObjectsResponse, error) {
	out := new(ImportNatObjectsResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapNatObjectService/ImportNatObjects", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapNatObjectServiceServer is the server API for NapNatObjectService service.
// All implementations must embed UnimplementedNapNatObjectServiceServer
// for forward compatibility
type NapNatObjectServiceServer interface {
	ImportNatObjects(context.Context, *WithNatObjectsAndDeviceRequest) (*ImportNatObjectsResponse, error)
	mustEmbedUnimplementedNapNatObjectServiceServer()
}

// UnimplementedNapNatObjectServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapNatObjectServiceServer struct {
}

func (UnimplementedNapNatObjectServiceServer) ImportNatObjects(context.Context, *WithNatObjectsAndDeviceRequest) (*ImportNatObjectsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportNatObjects not implemented")
}
func (UnimplementedNapNatObjectServiceServer) mustEmbedUnimplementedNapNatObjectServiceServer() {}

// UnsafeNapNatObjectServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapNatObjectServiceServer will
// result in compilation errors.
type UnsafeNapNatObjectServiceServer interface {
	mustEmbedUnimplementedNapNatObjectServiceServer()
}

func RegisterNapNatObjectServiceServer(s grpc.ServiceRegistrar, srv NapNatObjectServiceServer) {
	s.RegisterService(&NapNatObjectService_ServiceDesc, srv)
}

func _NapNatObjectService_ImportNatObjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithNatObjectsAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapNatObjectServiceServer).ImportNatObjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapNatObjectService/ImportNatObjects",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapNatObjectServiceServer).ImportNatObjects(ctx, req.(*WithNatObjectsAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapNatObjectService_ServiceDesc is the grpc.ServiceDesc for NapNatObjectService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapNatObjectService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapNatObjectService",
	HandlerType: (*NapNatObjectServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportNatObjects",
			Handler:    _NapNatObjectService_ImportNatObjects_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapNatPoolServiceClient is the client API for NapNatPoolService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapNatPoolServiceClient interface {
	ImportNatPools(ctx context.Context, in *WithNatPoolsAndDeviceRequest, opts ...grpc.CallOption) (*ImportNatPoolsResponse, error)
}

type napNatPoolServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapNatPoolServiceClient(cc grpc.ClientConnInterface) NapNatPoolServiceClient {
	return &napNatPoolServiceClient{cc}
}

func (c *napNatPoolServiceClient) ImportNatPools(ctx context.Context, in *WithNatPoolsAndDeviceRequest, opts ...grpc.CallOption) (*ImportNatPoolsResponse, error) {
	out := new(ImportNatPoolsResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapNatPoolService/ImportNatPools", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapNatPoolServiceServer is the server API for NapNatPoolService service.
// All implementations must embed UnimplementedNapNatPoolServiceServer
// for forward compatibility
type NapNatPoolServiceServer interface {
	ImportNatPools(context.Context, *WithNatPoolsAndDeviceRequest) (*ImportNatPoolsResponse, error)
	mustEmbedUnimplementedNapNatPoolServiceServer()
}

// UnimplementedNapNatPoolServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapNatPoolServiceServer struct {
}

func (UnimplementedNapNatPoolServiceServer) ImportNatPools(context.Context, *WithNatPoolsAndDeviceRequest) (*ImportNatPoolsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportNatPools not implemented")
}
func (UnimplementedNapNatPoolServiceServer) mustEmbedUnimplementedNapNatPoolServiceServer() {}

// UnsafeNapNatPoolServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapNatPoolServiceServer will
// result in compilation errors.
type UnsafeNapNatPoolServiceServer interface {
	mustEmbedUnimplementedNapNatPoolServiceServer()
}

func RegisterNapNatPoolServiceServer(s grpc.ServiceRegistrar, srv NapNatPoolServiceServer) {
	s.RegisterService(&NapNatPoolService_ServiceDesc, srv)
}

func _NapNatPoolService_ImportNatPools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithNatPoolsAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapNatPoolServiceServer).ImportNatPools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapNatPoolService/ImportNatPools",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapNatPoolServiceServer).ImportNatPools(ctx, req.(*WithNatPoolsAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapNatPoolService_ServiceDesc is the grpc.ServiceDesc for NapNatPoolService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapNatPoolService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapNatPoolService",
	HandlerType: (*NapNatPoolServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportNatPools",
			Handler:    _NapNatPoolService_ImportNatPools_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapRuleSetServiceClient is the client API for NapRuleSetService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapRuleSetServiceClient interface {
	ImportRuleSet(ctx context.Context, in *WithRuleSetAndDeviceRequest, opts ...grpc.CallOption) (*ImportRuleSetResponse, error)
}

type napRuleSetServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapRuleSetServiceClient(cc grpc.ClientConnInterface) NapRuleSetServiceClient {
	return &napRuleSetServiceClient{cc}
}

func (c *napRuleSetServiceClient) ImportRuleSet(ctx context.Context, in *WithRuleSetAndDeviceRequest, opts ...grpc.CallOption) (*ImportRuleSetResponse, error) {
	out := new(ImportRuleSetResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapRuleSetService/ImportRuleSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapRuleSetServiceServer is the server API for NapRuleSetService service.
// All implementations must embed UnimplementedNapRuleSetServiceServer
// for forward compatibility
type NapRuleSetServiceServer interface {
	ImportRuleSet(context.Context, *WithRuleSetAndDeviceRequest) (*ImportRuleSetResponse, error)
	mustEmbedUnimplementedNapRuleSetServiceServer()
}

// UnimplementedNapRuleSetServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapRuleSetServiceServer struct {
}

func (UnimplementedNapRuleSetServiceServer) ImportRuleSet(context.Context, *WithRuleSetAndDeviceRequest) (*ImportRuleSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportRuleSet not implemented")
}
func (UnimplementedNapRuleSetServiceServer) mustEmbedUnimplementedNapRuleSetServiceServer() {}

// UnsafeNapRuleSetServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapRuleSetServiceServer will
// result in compilation errors.
type UnsafeNapRuleSetServiceServer interface {
	mustEmbedUnimplementedNapRuleSetServiceServer()
}

func RegisterNapRuleSetServiceServer(s grpc.ServiceRegistrar, srv NapRuleSetServiceServer) {
	s.RegisterService(&NapRuleSetService_ServiceDesc, srv)
}

func _NapRuleSetService_ImportRuleSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithRuleSetAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapRuleSetServiceServer).ImportRuleSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapRuleSetService/ImportRuleSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapRuleSetServiceServer).ImportRuleSet(ctx, req.(*WithRuleSetAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapRuleSetService_ServiceDesc is the grpc.ServiceDesc for NapRuleSetService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapRuleSetService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapRuleSetService",
	HandlerType: (*NapRuleSetServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportRuleSet",
			Handler:    _NapRuleSetService_ImportRuleSet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapVipServiceClient is the client API for NapVipService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapVipServiceClient interface {
	ImportVips(ctx context.Context, in *WithVipsAndDeviceRequest, opts ...grpc.CallOption) (*ImportVipsResponse, error)
}

type napVipServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapVipServiceClient(cc grpc.ClientConnInterface) NapVipServiceClient {
	return &napVipServiceClient{cc}
}

func (c *napVipServiceClient) ImportVips(ctx context.Context, in *WithVipsAndDeviceRequest, opts ...grpc.CallOption) (*ImportVipsResponse, error) {
	out := new(ImportVipsResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapVipService/ImportVips", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapVipServiceServer is the server API for NapVipService service.
// All implementations must embed UnimplementedNapVipServiceServer
// for forward compatibility
type NapVipServiceServer interface {
	ImportVips(context.Context, *WithVipsAndDeviceRequest) (*ImportVipsResponse, error)
	mustEmbedUnimplementedNapVipServiceServer()
}

// UnimplementedNapVipServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapVipServiceServer struct {
}

func (UnimplementedNapVipServiceServer) ImportVips(context.Context, *WithVipsAndDeviceRequest) (*ImportVipsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportVips not implemented")
}
func (UnimplementedNapVipServiceServer) mustEmbedUnimplementedNapVipServiceServer() {}

// UnsafeNapVipServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapVipServiceServer will
// result in compilation errors.
type UnsafeNapVipServiceServer interface {
	mustEmbedUnimplementedNapVipServiceServer()
}

func RegisterNapVipServiceServer(s grpc.ServiceRegistrar, srv NapVipServiceServer) {
	s.RegisterService(&NapVipService_ServiceDesc, srv)
}

func _NapVipService_ImportVips_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithVipsAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapVipServiceServer).ImportVips(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapVipService/ImportVips",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapVipServiceServer).ImportVips(ctx, req.(*WithVipsAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapVipService_ServiceDesc is the grpc.ServiceDesc for NapVipService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapVipService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapVipService",
	HandlerType: (*NapVipServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportVips",
			Handler:    _NapVipService_ImportVips_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapScheduleServiceClient is the client API for NapScheduleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapScheduleServiceClient interface {
	ImportSchedules(ctx context.Context, in *WithSchedulesAndDeviceRequest, opts ...grpc.CallOption) (*ImportSchedulesResponse, error)
}

type napScheduleServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapScheduleServiceClient(cc grpc.ClientConnInterface) NapScheduleServiceClient {
	return &napScheduleServiceClient{cc}
}

func (c *napScheduleServiceClient) ImportSchedules(ctx context.Context, in *WithSchedulesAndDeviceRequest, opts ...grpc.CallOption) (*ImportSchedulesResponse, error) {
	out := new(ImportSchedulesResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapScheduleService/ImportSchedules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapScheduleServiceServer is the server API for NapScheduleService service.
// All implementations must embed UnimplementedNapScheduleServiceServer
// for forward compatibility
type NapScheduleServiceServer interface {
	ImportSchedules(context.Context, *WithSchedulesAndDeviceRequest) (*ImportSchedulesResponse, error)
	mustEmbedUnimplementedNapScheduleServiceServer()
}

// UnimplementedNapScheduleServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapScheduleServiceServer struct {
}

func (UnimplementedNapScheduleServiceServer) ImportSchedules(context.Context, *WithSchedulesAndDeviceRequest) (*ImportSchedulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportSchedules not implemented")
}
func (UnimplementedNapScheduleServiceServer) mustEmbedUnimplementedNapScheduleServiceServer() {}

// UnsafeNapScheduleServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapScheduleServiceServer will
// result in compilation errors.
type UnsafeNapScheduleServiceServer interface {
	mustEmbedUnimplementedNapScheduleServiceServer()
}

func RegisterNapScheduleServiceServer(s grpc.ServiceRegistrar, srv NapScheduleServiceServer) {
	s.RegisterService(&NapScheduleService_ServiceDesc, srv)
}

func _NapScheduleService_ImportSchedules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithSchedulesAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapScheduleServiceServer).ImportSchedules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapScheduleService/ImportSchedules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapScheduleServiceServer).ImportSchedules(ctx, req.(*WithSchedulesAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapScheduleService_ServiceDesc is the grpc.ServiceDesc for NapScheduleService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapScheduleService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapScheduleService",
	HandlerType: (*NapScheduleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportSchedules",
			Handler:    _NapScheduleService_ImportSchedules_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapSvcServiceClient is the client API for NapSvcService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapSvcServiceClient interface {
	ImportServices(ctx context.Context, in *WithServicesAndDeviceRequest, opts ...grpc.CallOption) (*ImportServicesResponse, error)
}

type napSvcServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapSvcServiceClient(cc grpc.ClientConnInterface) NapSvcServiceClient {
	return &napSvcServiceClient{cc}
}

func (c *napSvcServiceClient) ImportServices(ctx context.Context, in *WithServicesAndDeviceRequest, opts ...grpc.CallOption) (*ImportServicesResponse, error) {
	out := new(ImportServicesResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapSvcService/ImportServices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapSvcServiceServer is the server API for NapSvcService service.
// All implementations must embed UnimplementedNapSvcServiceServer
// for forward compatibility
type NapSvcServiceServer interface {
	ImportServices(context.Context, *WithServicesAndDeviceRequest) (*ImportServicesResponse, error)
	mustEmbedUnimplementedNapSvcServiceServer()
}

// UnimplementedNapSvcServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapSvcServiceServer struct {
}

func (UnimplementedNapSvcServiceServer) ImportServices(context.Context, *WithServicesAndDeviceRequest) (*ImportServicesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportServices not implemented")
}
func (UnimplementedNapSvcServiceServer) mustEmbedUnimplementedNapSvcServiceServer() {}

// UnsafeNapSvcServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapSvcServiceServer will
// result in compilation errors.
type UnsafeNapSvcServiceServer interface {
	mustEmbedUnimplementedNapSvcServiceServer()
}

func RegisterNapSvcServiceServer(s grpc.ServiceRegistrar, srv NapSvcServiceServer) {
	s.RegisterService(&NapSvcService_ServiceDesc, srv)
}

func _NapSvcService_ImportServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithServicesAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapSvcServiceServer).ImportServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapSvcService/ImportServices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapSvcServiceServer).ImportServices(ctx, req.(*WithServicesAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapSvcService_ServiceDesc is the grpc.ServiceDesc for NapSvcService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapSvcService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapSvcService",
	HandlerType: (*NapSvcServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportServices",
			Handler:    _NapSvcService_ImportServices_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapRouteServiceClient is the client API for NapRouteService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapRouteServiceClient interface {
	ImportRoutes(ctx context.Context, in *WithRoutesAndDeviceRequest, opts ...grpc.CallOption) (*ImportRoutesResponse, error)
}

type napRouteServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapRouteServiceClient(cc grpc.ClientConnInterface) NapRouteServiceClient {
	return &napRouteServiceClient{cc}
}

func (c *napRouteServiceClient) ImportRoutes(ctx context.Context, in *WithRoutesAndDeviceRequest, opts ...grpc.CallOption) (*ImportRoutesResponse, error) {
	out := new(ImportRoutesResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapRouteService/ImportRoutes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapRouteServiceServer is the server API for NapRouteService service.
// All implementations must embed UnimplementedNapRouteServiceServer
// for forward compatibility
type NapRouteServiceServer interface {
	ImportRoutes(context.Context, *WithRoutesAndDeviceRequest) (*ImportRoutesResponse, error)
	mustEmbedUnimplementedNapRouteServiceServer()
}

// UnimplementedNapRouteServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapRouteServiceServer struct {
}

func (UnimplementedNapRouteServiceServer) ImportRoutes(context.Context, *WithRoutesAndDeviceRequest) (*ImportRoutesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportRoutes not implemented")
}
func (UnimplementedNapRouteServiceServer) mustEmbedUnimplementedNapRouteServiceServer() {}

// UnsafeNapRouteServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapRouteServiceServer will
// result in compilation errors.
type UnsafeNapRouteServiceServer interface {
	mustEmbedUnimplementedNapRouteServiceServer()
}

func RegisterNapRouteServiceServer(s grpc.ServiceRegistrar, srv NapRouteServiceServer) {
	s.RegisterService(&NapRouteService_ServiceDesc, srv)
}

func _NapRouteService_ImportRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithRoutesAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapRouteServiceServer).ImportRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapRouteService/ImportRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapRouteServiceServer).ImportRoutes(ctx, req.(*WithRoutesAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapRouteService_ServiceDesc is the grpc.ServiceDesc for NapRouteService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapRouteService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapRouteService",
	HandlerType: (*NapRouteServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportRoutes",
			Handler:    _NapRouteService_ImportRoutes_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapPolicyServiceClient is the client API for NapPolicyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapPolicyServiceClient interface {
	ImportPolicies(ctx context.Context, in *WithPoliciesAndDeviceRequest, opts ...grpc.CallOption) (*ImportPoliciesResponse, error)
}

type napPolicyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapPolicyServiceClient(cc grpc.ClientConnInterface) NapPolicyServiceClient {
	return &napPolicyServiceClient{cc}
}

func (c *napPolicyServiceClient) ImportPolicies(ctx context.Context, in *WithPoliciesAndDeviceRequest, opts ...grpc.CallOption) (*ImportPoliciesResponse, error) {
	out := new(ImportPoliciesResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapPolicyService/ImportPolicies", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapPolicyServiceServer is the server API for NapPolicyService service.
// All implementations must embed UnimplementedNapPolicyServiceServer
// for forward compatibility
type NapPolicyServiceServer interface {
	ImportPolicies(context.Context, *WithPoliciesAndDeviceRequest) (*ImportPoliciesResponse, error)
	mustEmbedUnimplementedNapPolicyServiceServer()
}

// UnimplementedNapPolicyServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapPolicyServiceServer struct {
}

func (UnimplementedNapPolicyServiceServer) ImportPolicies(context.Context, *WithPoliciesAndDeviceRequest) (*ImportPoliciesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportPolicies not implemented")
}
func (UnimplementedNapPolicyServiceServer) mustEmbedUnimplementedNapPolicyServiceServer() {}

// UnsafeNapPolicyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapPolicyServiceServer will
// result in compilation errors.
type UnsafeNapPolicyServiceServer interface {
	mustEmbedUnimplementedNapPolicyServiceServer()
}

func RegisterNapPolicyServiceServer(s grpc.ServiceRegistrar, srv NapPolicyServiceServer) {
	s.RegisterService(&NapPolicyService_ServiceDesc, srv)
}

func _NapPolicyService_ImportPolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithPoliciesAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapPolicyServiceServer).ImportPolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapPolicyService/ImportPolicies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapPolicyServiceServer).ImportPolicies(ctx, req.(*WithPoliciesAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapPolicyService_ServiceDesc is the grpc.ServiceDesc for NapPolicyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapPolicyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapPolicyService",
	HandlerType: (*NapPolicyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportPolicies",
			Handler:    _NapPolicyService_ImportPolicies_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapApplicationServiceClient is the client API for NapApplicationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapApplicationServiceClient interface {
	ImportApplications(ctx context.Context, in *WithApplicationsAndDeviceRequest, opts ...grpc.CallOption) (*ImportApplicationsResponse, error)
}

type napApplicationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapApplicationServiceClient(cc grpc.ClientConnInterface) NapApplicationServiceClient {
	return &napApplicationServiceClient{cc}
}

func (c *napApplicationServiceClient) ImportApplications(ctx context.Context, in *WithApplicationsAndDeviceRequest, opts ...grpc.CallOption) (*ImportApplicationsResponse, error) {
	out := new(ImportApplicationsResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapApplicationService/ImportApplications", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapApplicationServiceServer is the server API for NapApplicationService service.
// All implementations must embed UnimplementedNapApplicationServiceServer
// for forward compatibility
type NapApplicationServiceServer interface {
	ImportApplications(context.Context, *WithApplicationsAndDeviceRequest) (*ImportApplicationsResponse, error)
	mustEmbedUnimplementedNapApplicationServiceServer()
}

// UnimplementedNapApplicationServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapApplicationServiceServer struct {
}

func (UnimplementedNapApplicationServiceServer) ImportApplications(context.Context, *WithApplicationsAndDeviceRequest) (*ImportApplicationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportApplications not implemented")
}
func (UnimplementedNapApplicationServiceServer) mustEmbedUnimplementedNapApplicationServiceServer() {}

// UnsafeNapApplicationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapApplicationServiceServer will
// result in compilation errors.
type UnsafeNapApplicationServiceServer interface {
	mustEmbedUnimplementedNapApplicationServiceServer()
}

func RegisterNapApplicationServiceServer(s grpc.ServiceRegistrar, srv NapApplicationServiceServer) {
	s.RegisterService(&NapApplicationService_ServiceDesc, srv)
}

func _NapApplicationService_ImportApplications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithApplicationsAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapApplicationServiceServer).ImportApplications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapApplicationService/ImportApplications",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapApplicationServiceServer).ImportApplications(ctx, req.(*WithApplicationsAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapApplicationService_ServiceDesc is the grpc.ServiceDesc for NapApplicationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapApplicationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapApplicationService",
	HandlerType: (*NapApplicationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportApplications",
			Handler:    _NapApplicationService_ImportApplications_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapHitCountServiceClient is the client API for NapHitCountService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapHitCountServiceClient interface {
	ImportHitCounts(ctx context.Context, in *WithHitCountAndDeviceRequest, opts ...grpc.CallOption) (*ImportHitCountsResponse, error)
}

type napHitCountServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapHitCountServiceClient(cc grpc.ClientConnInterface) NapHitCountServiceClient {
	return &napHitCountServiceClient{cc}
}

func (c *napHitCountServiceClient) ImportHitCounts(ctx context.Context, in *WithHitCountAndDeviceRequest, opts ...grpc.CallOption) (*ImportHitCountsResponse, error) {
	out := new(ImportHitCountsResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapHitCountService/ImportHitCounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapHitCountServiceServer is the server API for NapHitCountService service.
// All implementations must embed UnimplementedNapHitCountServiceServer
// for forward compatibility
type NapHitCountServiceServer interface {
	ImportHitCounts(context.Context, *WithHitCountAndDeviceRequest) (*ImportHitCountsResponse, error)
	mustEmbedUnimplementedNapHitCountServiceServer()
}

// UnimplementedNapHitCountServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapHitCountServiceServer struct {
}

func (UnimplementedNapHitCountServiceServer) ImportHitCounts(context.Context, *WithHitCountAndDeviceRequest) (*ImportHitCountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportHitCounts not implemented")
}
func (UnimplementedNapHitCountServiceServer) mustEmbedUnimplementedNapHitCountServiceServer() {}

// UnsafeNapHitCountServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapHitCountServiceServer will
// result in compilation errors.
type UnsafeNapHitCountServiceServer interface {
	mustEmbedUnimplementedNapHitCountServiceServer()
}

func RegisterNapHitCountServiceServer(s grpc.ServiceRegistrar, srv NapHitCountServiceServer) {
	s.RegisterService(&NapHitCountService_ServiceDesc, srv)
}

func _NapHitCountService_ImportHitCounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithHitCountAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapHitCountServiceServer).ImportHitCounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapHitCountService/ImportHitCounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapHitCountServiceServer).ImportHitCounts(ctx, req.(*WithHitCountAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapHitCountService_ServiceDesc is the grpc.ServiceDesc for NapHitCountService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapHitCountService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapHitCountService",
	HandlerType: (*NapHitCountServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportHitCounts",
			Handler:    _NapHitCountService_ImportHitCounts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapUserIDServiceClient is the client API for NapUserIDService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapUserIDServiceClient interface {
	ImportUserIDs(ctx context.Context, in *WithUserIDsAndDeviceRequest, opts ...grpc.CallOption) (*ImportUserIDsResponse, error)
}

type napUserIDServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapUserIDServiceClient(cc grpc.ClientConnInterface) NapUserIDServiceClient {
	return &napUserIDServiceClient{cc}
}

func (c *napUserIDServiceClient) ImportUserIDs(ctx context.Context, in *WithUserIDsAndDeviceRequest, opts ...grpc.CallOption) (*ImportUserIDsResponse, error) {
	out := new(ImportUserIDsResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapUserIDService/ImportUserIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapUserIDServiceServer is the server API for NapUserIDService service.
// All implementations must embed UnimplementedNapUserIDServiceServer
// for forward compatibility
type NapUserIDServiceServer interface {
	ImportUserIDs(context.Context, *WithUserIDsAndDeviceRequest) (*ImportUserIDsResponse, error)
	mustEmbedUnimplementedNapUserIDServiceServer()
}

// UnimplementedNapUserIDServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapUserIDServiceServer struct {
}

func (UnimplementedNapUserIDServiceServer) ImportUserIDs(context.Context, *WithUserIDsAndDeviceRequest) (*ImportUserIDsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportUserIDs not implemented")
}
func (UnimplementedNapUserIDServiceServer) mustEmbedUnimplementedNapUserIDServiceServer() {}

// UnsafeNapUserIDServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapUserIDServiceServer will
// result in compilation errors.
type UnsafeNapUserIDServiceServer interface {
	mustEmbedUnimplementedNapUserIDServiceServer()
}

func RegisterNapUserIDServiceServer(s grpc.ServiceRegistrar, srv NapUserIDServiceServer) {
	s.RegisterService(&NapUserIDService_ServiceDesc, srv)
}

func _NapUserIDService_ImportUserIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithUserIDsAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapUserIDServiceServer).ImportUserIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapUserIDService/ImportUserIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapUserIDServiceServer).ImportUserIDs(ctx, req.(*WithUserIDsAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapUserIDService_ServiceDesc is the grpc.ServiceDesc for NapUserIDService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapUserIDService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapUserIDService",
	HandlerType: (*NapUserIDServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportUserIDs",
			Handler:    _NapUserIDService_ImportUserIDs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapAccessGroupServiceClient is the client API for NapAccessGroupService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapAccessGroupServiceClient interface {
	ImportAccessGroups(ctx context.Context, in *WithAccessGroupsAndDeviceRequest, opts ...grpc.CallOption) (*ImportAccessGroupsResponse, error)
}

type napAccessGroupServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapAccessGroupServiceClient(cc grpc.ClientConnInterface) NapAccessGroupServiceClient {
	return &napAccessGroupServiceClient{cc}
}

func (c *napAccessGroupServiceClient) ImportAccessGroups(ctx context.Context, in *WithAccessGroupsAndDeviceRequest, opts ...grpc.CallOption) (*ImportAccessGroupsResponse, error) {
	out := new(ImportAccessGroupsResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapAccessGroupService/ImportAccessGroups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapAccessGroupServiceServer is the server API for NapAccessGroupService service.
// All implementations must embed UnimplementedNapAccessGroupServiceServer
// for forward compatibility
type NapAccessGroupServiceServer interface {
	ImportAccessGroups(context.Context, *WithAccessGroupsAndDeviceRequest) (*ImportAccessGroupsResponse, error)
	mustEmbedUnimplementedNapAccessGroupServiceServer()
}

// UnimplementedNapAccessGroupServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapAccessGroupServiceServer struct {
}

func (UnimplementedNapAccessGroupServiceServer) ImportAccessGroups(context.Context, *WithAccessGroupsAndDeviceRequest) (*ImportAccessGroupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportAccessGroups not implemented")
}
func (UnimplementedNapAccessGroupServiceServer) mustEmbedUnimplementedNapAccessGroupServiceServer() {}

// UnsafeNapAccessGroupServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapAccessGroupServiceServer will
// result in compilation errors.
type UnsafeNapAccessGroupServiceServer interface {
	mustEmbedUnimplementedNapAccessGroupServiceServer()
}

func RegisterNapAccessGroupServiceServer(s grpc.ServiceRegistrar, srv NapAccessGroupServiceServer) {
	s.RegisterService(&NapAccessGroupService_ServiceDesc, srv)
}

func _NapAccessGroupService_ImportAccessGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithAccessGroupsAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapAccessGroupServiceServer).ImportAccessGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapAccessGroupService/ImportAccessGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapAccessGroupServiceServer).ImportAccessGroups(ctx, req.(*WithAccessGroupsAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapAccessGroupService_ServiceDesc is the grpc.ServiceDesc for NapAccessGroupService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapAccessGroupService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapAccessGroupService",
	HandlerType: (*NapAccessGroupServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportAccessGroups",
			Handler:    _NapAccessGroupService_ImportAccessGroups_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapVrfsServiceClient is the client API for NapVrfsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapVrfsServiceClient interface {
	ImportVrfs(ctx context.Context, in *WithVrfsAndDeviceRequest, opts ...grpc.CallOption) (*ImportVrfsResponse, error)
}

type napVrfsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapVrfsServiceClient(cc grpc.ClientConnInterface) NapVrfsServiceClient {
	return &napVrfsServiceClient{cc}
}

func (c *napVrfsServiceClient) ImportVrfs(ctx context.Context, in *WithVrfsAndDeviceRequest, opts ...grpc.CallOption) (*ImportVrfsResponse, error) {
	out := new(ImportVrfsResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapVrfsService/ImportVrfs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapVrfsServiceServer is the server API for NapVrfsService service.
// All implementations must embed UnimplementedNapVrfsServiceServer
// for forward compatibility
type NapVrfsServiceServer interface {
	ImportVrfs(context.Context, *WithVrfsAndDeviceRequest) (*ImportVrfsResponse, error)
	mustEmbedUnimplementedNapVrfsServiceServer()
}

// UnimplementedNapVrfsServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapVrfsServiceServer struct {
}

func (UnimplementedNapVrfsServiceServer) ImportVrfs(context.Context, *WithVrfsAndDeviceRequest) (*ImportVrfsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportVrfs not implemented")
}
func (UnimplementedNapVrfsServiceServer) mustEmbedUnimplementedNapVrfsServiceServer() {}

// UnsafeNapVrfsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapVrfsServiceServer will
// result in compilation errors.
type UnsafeNapVrfsServiceServer interface {
	mustEmbedUnimplementedNapVrfsServiceServer()
}

func RegisterNapVrfsServiceServer(s grpc.ServiceRegistrar, srv NapVrfsServiceServer) {
	s.RegisterService(&NapVrfsService_ServiceDesc, srv)
}

func _NapVrfsService_ImportVrfs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithVrfsAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapVrfsServiceServer).ImportVrfs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapVrfsService/ImportVrfs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapVrfsServiceServer).ImportVrfs(ctx, req.(*WithVrfsAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapVrfsService_ServiceDesc is the grpc.ServiceDesc for NapVrfsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapVrfsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapVrfsService",
	HandlerType: (*NapVrfsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportVrfs",
			Handler:    _NapVrfsService_ImportVrfs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapVlanServiceClient is the client API for NapVlanService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapVlanServiceClient interface {
	ImportVlans(ctx context.Context, in *WithVlansAndDeviceRequest, opts ...grpc.CallOption) (*ImportVlansResponse, error)
}

type napVlanServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapVlanServiceClient(cc grpc.ClientConnInterface) NapVlanServiceClient {
	return &napVlanServiceClient{cc}
}

func (c *napVlanServiceClient) ImportVlans(ctx context.Context, in *WithVlansAndDeviceRequest, opts ...grpc.CallOption) (*ImportVlansResponse, error) {
	out := new(ImportVlansResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapVlanService/ImportVlans", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapVlanServiceServer is the server API for NapVlanService service.
// All implementations must embed UnimplementedNapVlanServiceServer
// for forward compatibility
type NapVlanServiceServer interface {
	ImportVlans(context.Context, *WithVlansAndDeviceRequest) (*ImportVlansResponse, error)
	mustEmbedUnimplementedNapVlanServiceServer()
}

// UnimplementedNapVlanServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapVlanServiceServer struct {
}

func (UnimplementedNapVlanServiceServer) ImportVlans(context.Context, *WithVlansAndDeviceRequest) (*ImportVlansResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportVlans not implemented")
}
func (UnimplementedNapVlanServiceServer) mustEmbedUnimplementedNapVlanServiceServer() {}

// UnsafeNapVlanServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapVlanServiceServer will
// result in compilation errors.
type UnsafeNapVlanServiceServer interface {
	mustEmbedUnimplementedNapVlanServiceServer()
}

func RegisterNapVlanServiceServer(s grpc.ServiceRegistrar, srv NapVlanServiceServer) {
	s.RegisterService(&NapVlanService_ServiceDesc, srv)
}

func _NapVlanService_ImportVlans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithVlansAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapVlanServiceServer).ImportVlans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapVlanService/ImportVlans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapVlanServiceServer).ImportVlans(ctx, req.(*WithVlansAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapVlanService_ServiceDesc is the grpc.ServiceDesc for NapVlanService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapVlanService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapVlanService",
	HandlerType: (*NapVlanServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportVlans",
			Handler:    _NapVlanService_ImportVlans_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapProfileServiceClient is the client API for NapProfileService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapProfileServiceClient interface {
	ImportProfiles(ctx context.Context, in *WithProfilesAndDeviceRequest, opts ...grpc.CallOption) (*ImportProfilesResponse, error)
	ImportUrlProfiles(ctx context.Context, in *WithProfilesAndDeviceRequest, opts ...grpc.CallOption) (*ImportProfilesResponse, error)
}

type napProfileServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapProfileServiceClient(cc grpc.ClientConnInterface) NapProfileServiceClient {
	return &napProfileServiceClient{cc}
}

func (c *napProfileServiceClient) ImportProfiles(ctx context.Context, in *WithProfilesAndDeviceRequest, opts ...grpc.CallOption) (*ImportProfilesResponse, error) {
	out := new(ImportProfilesResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapProfileService/ImportProfiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *napProfileServiceClient) ImportUrlProfiles(ctx context.Context, in *WithProfilesAndDeviceRequest, opts ...grpc.CallOption) (*ImportProfilesResponse, error) {
	out := new(ImportProfilesResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapProfileService/ImportUrlProfiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapProfileServiceServer is the server API for NapProfileService service.
// All implementations must embed UnimplementedNapProfileServiceServer
// for forward compatibility
type NapProfileServiceServer interface {
	ImportProfiles(context.Context, *WithProfilesAndDeviceRequest) (*ImportProfilesResponse, error)
	ImportUrlProfiles(context.Context, *WithProfilesAndDeviceRequest) (*ImportProfilesResponse, error)
	mustEmbedUnimplementedNapProfileServiceServer()
}

// UnimplementedNapProfileServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapProfileServiceServer struct {
}

func (UnimplementedNapProfileServiceServer) ImportProfiles(context.Context, *WithProfilesAndDeviceRequest) (*ImportProfilesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportProfiles not implemented")
}
func (UnimplementedNapProfileServiceServer) ImportUrlProfiles(context.Context, *WithProfilesAndDeviceRequest) (*ImportProfilesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportUrlProfiles not implemented")
}
func (UnimplementedNapProfileServiceServer) mustEmbedUnimplementedNapProfileServiceServer() {}

// UnsafeNapProfileServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapProfileServiceServer will
// result in compilation errors.
type UnsafeNapProfileServiceServer interface {
	mustEmbedUnimplementedNapProfileServiceServer()
}

func RegisterNapProfileServiceServer(s grpc.ServiceRegistrar, srv NapProfileServiceServer) {
	s.RegisterService(&NapProfileService_ServiceDesc, srv)
}

func _NapProfileService_ImportProfiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithProfilesAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapProfileServiceServer).ImportProfiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapProfileService/ImportProfiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapProfileServiceServer).ImportProfiles(ctx, req.(*WithProfilesAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NapProfileService_ImportUrlProfiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithProfilesAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapProfileServiceServer).ImportUrlProfiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapProfileService/ImportUrlProfiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapProfileServiceServer).ImportUrlProfiles(ctx, req.(*WithProfilesAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapProfileService_ServiceDesc is the grpc.ServiceDesc for NapProfileService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapProfileService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapProfileService",
	HandlerType: (*NapProfileServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportProfiles",
			Handler:    _NapProfileService_ImportProfiles_Handler,
		},
		{
			MethodName: "ImportUrlProfiles",
			Handler:    _NapProfileService_ImportUrlProfiles_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapPbrServiceClient is the client API for NapPbrService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapPbrServiceClient interface {
	ImportPbrs(ctx context.Context, in *WithPbrsAndDeviceRequest, opts ...grpc.CallOption) (*ImportPbrsResponse, error)
}

type napPbrServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapPbrServiceClient(cc grpc.ClientConnInterface) NapPbrServiceClient {
	return &napPbrServiceClient{cc}
}

func (c *napPbrServiceClient) ImportPbrs(ctx context.Context, in *WithPbrsAndDeviceRequest, opts ...grpc.CallOption) (*ImportPbrsResponse, error) {
	out := new(ImportPbrsResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapPbrService/ImportPbrs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapPbrServiceServer is the server API for NapPbrService service.
// All implementations must embed UnimplementedNapPbrServiceServer
// for forward compatibility
type NapPbrServiceServer interface {
	ImportPbrs(context.Context, *WithPbrsAndDeviceRequest) (*ImportPbrsResponse, error)
	mustEmbedUnimplementedNapPbrServiceServer()
}

// UnimplementedNapPbrServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapPbrServiceServer struct {
}

func (UnimplementedNapPbrServiceServer) ImportPbrs(context.Context, *WithPbrsAndDeviceRequest) (*ImportPbrsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportPbrs not implemented")
}
func (UnimplementedNapPbrServiceServer) mustEmbedUnimplementedNapPbrServiceServer() {}

// UnsafeNapPbrServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapPbrServiceServer will
// result in compilation errors.
type UnsafeNapPbrServiceServer interface {
	mustEmbedUnimplementedNapPbrServiceServer()
}

func RegisterNapPbrServiceServer(s grpc.ServiceRegistrar, srv NapPbrServiceServer) {
	s.RegisterService(&NapPbrService_ServiceDesc, srv)
}

func _NapPbrService_ImportPbrs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithPbrsAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapPbrServiceServer).ImportPbrs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapPbrService/ImportPbrs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapPbrServiceServer).ImportPbrs(ctx, req.(*WithPbrsAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapPbrService_ServiceDesc is the grpc.ServiceDesc for NapPbrService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapPbrService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapPbrService",
	HandlerType: (*NapPbrServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportPbrs",
			Handler:    _NapPbrService_ImportPbrs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapTopologyServiceClient is the client API for NapTopologyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapTopologyServiceClient interface {
	AnalyzePath(ctx context.Context, in *common.SimpleJsonRequest, opts ...grpc.CallOption) (*common.SimpleJsonResponse, error)
	AnalyzeInternet(ctx context.Context, in *common.SimpleJsonRequest, opts ...grpc.CallOption) (*common.SimpleJsonResponse, error)
}

type napTopologyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapTopologyServiceClient(cc grpc.ClientConnInterface) NapTopologyServiceClient {
	return &napTopologyServiceClient{cc}
}

func (c *napTopologyServiceClient) AnalyzePath(ctx context.Context, in *common.SimpleJsonRequest, opts ...grpc.CallOption) (*common.SimpleJsonResponse, error) {
	out := new(common.SimpleJsonResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapTopologyService/analyzePath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *napTopologyServiceClient) AnalyzeInternet(ctx context.Context, in *common.SimpleJsonRequest, opts ...grpc.CallOption) (*common.SimpleJsonResponse, error) {
	out := new(common.SimpleJsonResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapTopologyService/analyzeInternet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapTopologyServiceServer is the server API for NapTopologyService service.
// All implementations must embed UnimplementedNapTopologyServiceServer
// for forward compatibility
type NapTopologyServiceServer interface {
	AnalyzePath(context.Context, *common.SimpleJsonRequest) (*common.SimpleJsonResponse, error)
	AnalyzeInternet(context.Context, *common.SimpleJsonRequest) (*common.SimpleJsonResponse, error)
	mustEmbedUnimplementedNapTopologyServiceServer()
}

// UnimplementedNapTopologyServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapTopologyServiceServer struct {
}

func (UnimplementedNapTopologyServiceServer) AnalyzePath(context.Context, *common.SimpleJsonRequest) (*common.SimpleJsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AnalyzePath not implemented")
}
func (UnimplementedNapTopologyServiceServer) AnalyzeInternet(context.Context, *common.SimpleJsonRequest) (*common.SimpleJsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AnalyzeInternet not implemented")
}
func (UnimplementedNapTopologyServiceServer) mustEmbedUnimplementedNapTopologyServiceServer() {}

// UnsafeNapTopologyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapTopologyServiceServer will
// result in compilation errors.
type UnsafeNapTopologyServiceServer interface {
	mustEmbedUnimplementedNapTopologyServiceServer()
}

func RegisterNapTopologyServiceServer(s grpc.ServiceRegistrar, srv NapTopologyServiceServer) {
	s.RegisterService(&NapTopologyService_ServiceDesc, srv)
}

func _NapTopologyService_AnalyzePath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.SimpleJsonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapTopologyServiceServer).AnalyzePath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapTopologyService/analyzePath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapTopologyServiceServer).AnalyzePath(ctx, req.(*common.SimpleJsonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NapTopologyService_AnalyzeInternet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.SimpleJsonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapTopologyServiceServer).AnalyzeInternet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapTopologyService/analyzeInternet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapTopologyServiceServer).AnalyzeInternet(ctx, req.(*common.SimpleJsonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapTopologyService_ServiceDesc is the grpc.ServiceDesc for NapTopologyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapTopologyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapTopologyService",
	HandlerType: (*NapTopologyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "analyzePath",
			Handler:    _NapTopologyService_AnalyzePath_Handler,
		},
		{
			MethodName: "analyzeInternet",
			Handler:    _NapTopologyService_AnalyzeInternet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapApplicationGroupServiceClient is the client API for NapApplicationGroupService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapApplicationGroupServiceClient interface {
	ImportApplicationGroups(ctx context.Context, in *WithApplicationGroupsAndDeviceRequest, opts ...grpc.CallOption) (*ImportApplicationGroupsResponse, error)
}

type napApplicationGroupServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapApplicationGroupServiceClient(cc grpc.ClientConnInterface) NapApplicationGroupServiceClient {
	return &napApplicationGroupServiceClient{cc}
}

func (c *napApplicationGroupServiceClient) ImportApplicationGroups(ctx context.Context, in *WithApplicationGroupsAndDeviceRequest, opts ...grpc.CallOption) (*ImportApplicationGroupsResponse, error) {
	out := new(ImportApplicationGroupsResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapApplicationGroupService/ImportApplicationGroups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapApplicationGroupServiceServer is the server API for NapApplicationGroupService service.
// All implementations must embed UnimplementedNapApplicationGroupServiceServer
// for forward compatibility
type NapApplicationGroupServiceServer interface {
	ImportApplicationGroups(context.Context, *WithApplicationGroupsAndDeviceRequest) (*ImportApplicationGroupsResponse, error)
	mustEmbedUnimplementedNapApplicationGroupServiceServer()
}

// UnimplementedNapApplicationGroupServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapApplicationGroupServiceServer struct {
}

func (UnimplementedNapApplicationGroupServiceServer) ImportApplicationGroups(context.Context, *WithApplicationGroupsAndDeviceRequest) (*ImportApplicationGroupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportApplicationGroups not implemented")
}
func (UnimplementedNapApplicationGroupServiceServer) mustEmbedUnimplementedNapApplicationGroupServiceServer() {
}

// UnsafeNapApplicationGroupServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapApplicationGroupServiceServer will
// result in compilation errors.
type UnsafeNapApplicationGroupServiceServer interface {
	mustEmbedUnimplementedNapApplicationGroupServiceServer()
}

func RegisterNapApplicationGroupServiceServer(s grpc.ServiceRegistrar, srv NapApplicationGroupServiceServer) {
	s.RegisterService(&NapApplicationGroupService_ServiceDesc, srv)
}

func _NapApplicationGroupService_ImportApplicationGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithApplicationGroupsAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapApplicationGroupServiceServer).ImportApplicationGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapApplicationGroupService/ImportApplicationGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapApplicationGroupServiceServer).ImportApplicationGroups(ctx, req.(*WithApplicationGroupsAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapApplicationGroupService_ServiceDesc is the grpc.ServiceDesc for NapApplicationGroupService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapApplicationGroupService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapApplicationGroupService",
	HandlerType: (*NapApplicationGroupServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportApplicationGroups",
			Handler:    _NapApplicationGroupService_ImportApplicationGroups_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// NapUrlCategoryServiceClient is the client API for NapUrlCategoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NapUrlCategoryServiceClient interface {
	ImportUrlCategorys(ctx context.Context, in *WithUrlCategorysAndDeviceRequest, opts ...grpc.CallOption) (*ImportUrlCategorysResponse, error)
}

type napUrlCategoryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNapUrlCategoryServiceClient(cc grpc.ClientConnInterface) NapUrlCategoryServiceClient {
	return &napUrlCategoryServiceClient{cc}
}

func (c *napUrlCategoryServiceClient) ImportUrlCategorys(ctx context.Context, in *WithUrlCategorysAndDeviceRequest, opts ...grpc.CallOption) (*ImportUrlCategorysResponse, error) {
	out := new(ImportUrlCategorysResponse)
	err := c.cc.Invoke(ctx, "/rpc.NapUrlCategoryService/ImportUrlCategorys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NapUrlCategoryServiceServer is the server API for NapUrlCategoryService service.
// All implementations must embed UnimplementedNapUrlCategoryServiceServer
// for forward compatibility
type NapUrlCategoryServiceServer interface {
	ImportUrlCategorys(context.Context, *WithUrlCategorysAndDeviceRequest) (*ImportUrlCategorysResponse, error)
	mustEmbedUnimplementedNapUrlCategoryServiceServer()
}

// UnimplementedNapUrlCategoryServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNapUrlCategoryServiceServer struct {
}

func (UnimplementedNapUrlCategoryServiceServer) ImportUrlCategorys(context.Context, *WithUrlCategorysAndDeviceRequest) (*ImportUrlCategorysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportUrlCategorys not implemented")
}
func (UnimplementedNapUrlCategoryServiceServer) mustEmbedUnimplementedNapUrlCategoryServiceServer() {}

// UnsafeNapUrlCategoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NapUrlCategoryServiceServer will
// result in compilation errors.
type UnsafeNapUrlCategoryServiceServer interface {
	mustEmbedUnimplementedNapUrlCategoryServiceServer()
}

func RegisterNapUrlCategoryServiceServer(s grpc.ServiceRegistrar, srv NapUrlCategoryServiceServer) {
	s.RegisterService(&NapUrlCategoryService_ServiceDesc, srv)
}

func _NapUrlCategoryService_ImportUrlCategorys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithUrlCategorysAndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NapUrlCategoryServiceServer).ImportUrlCategorys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NapUrlCategoryService/ImportUrlCategorys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NapUrlCategoryServiceServer).ImportUrlCategorys(ctx, req.(*WithUrlCategorysAndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NapUrlCategoryService_ServiceDesc is the grpc.ServiceDesc for NapUrlCategoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NapUrlCategoryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NapUrlCategoryService",
	HandlerType: (*NapUrlCategoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportUrlCategorys",
			Handler:    _NapUrlCategoryService_ImportUrlCategorys_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}

// ContrailTopologyServiceClient is the client API for ContrailTopologyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ContrailTopologyServiceClient interface {
	InitTopology(ctx context.Context, in *ContrailTopologyRequest, opts ...grpc.CallOption) (*ContrailTopologyResponse, error)
}

type contrailTopologyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewContrailTopologyServiceClient(cc grpc.ClientConnInterface) ContrailTopologyServiceClient {
	return &contrailTopologyServiceClient{cc}
}

func (c *contrailTopologyServiceClient) InitTopology(ctx context.Context, in *ContrailTopologyRequest, opts ...grpc.CallOption) (*ContrailTopologyResponse, error) {
	out := new(ContrailTopologyResponse)
	err := c.cc.Invoke(ctx, "/rpc.ContrailTopologyService/InitTopology", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ContrailTopologyServiceServer is the server API for ContrailTopologyService service.
// All implementations must embed UnimplementedContrailTopologyServiceServer
// for forward compatibility
type ContrailTopologyServiceServer interface {
	InitTopology(context.Context, *ContrailTopologyRequest) (*ContrailTopologyResponse, error)
	mustEmbedUnimplementedContrailTopologyServiceServer()
}

// UnimplementedContrailTopologyServiceServer must be embedded to have forward compatible implementations.
type UnimplementedContrailTopologyServiceServer struct {
}

func (UnimplementedContrailTopologyServiceServer) InitTopology(context.Context, *ContrailTopologyRequest) (*ContrailTopologyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitTopology not implemented")
}
func (UnimplementedContrailTopologyServiceServer) mustEmbedUnimplementedContrailTopologyServiceServer() {
}

// UnsafeContrailTopologyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ContrailTopologyServiceServer will
// result in compilation errors.
type UnsafeContrailTopologyServiceServer interface {
	mustEmbedUnimplementedContrailTopologyServiceServer()
}

func RegisterContrailTopologyServiceServer(s grpc.ServiceRegistrar, srv ContrailTopologyServiceServer) {
	s.RegisterService(&ContrailTopologyService_ServiceDesc, srv)
}

func _ContrailTopologyService_InitTopology_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContrailTopologyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContrailTopologyServiceServer).InitTopology(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ContrailTopologyService/InitTopology",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContrailTopologyServiceServer).InitTopology(ctx, req.(*ContrailTopologyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ContrailTopologyService_ServiceDesc is the grpc.ServiceDesc for ContrailTopologyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ContrailTopologyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.ContrailTopologyService",
	HandlerType: (*ContrailTopologyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InitTopology",
			Handler:    _ContrailTopologyService_InitTopology_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/grpc/nap.proto",
}
